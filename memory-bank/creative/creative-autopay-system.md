# CREATIVE PHASE: Система автоплатежей для подписок

## 🎯 ОБЗОР ТВОРЧЕСКОЙ ФАЗЫ

**Задача**: Проработка пользовательского опыта и алгоритмов для системы автоматических платежей
**Уровень сложности**: Level 3 (Intermediate Feature)
**Компоненты для проработки**: 3

---

## 🎨 КОМПОНЕНТ 1: UX для автоплатежей в боте

### 🎯 ОПИСАНИЕ
Пользовательский интерфейс в Telegram боте для управления автоматическими платежами. Обеспечивает интуитивное управление автоплатежами, отображение статуса подписки и контроль над периодическими списаниями.

### 📋 ТРЕБОВАНИЯ И ОГРАНИЧЕНИЯ
- **Функциональные**: отображение информации о подписке, дате списания, отмена автоплатежей
- **UX**: простота для неопытных пользователей, интуитивность
- **Технические**: интеграция с aiogram, совместимость с существующим bot handler
- **Бизнес**: увеличение retention через автоматическое продление

### 🔄 АНАЛИЗ ОПЦИЙ

#### Опция 1: Отдельное меню "Автоплатежи"
**Плюсы:**
- Четкое разделение функций
- Подробная информация об автоплатежах
- Простота навигации

**Минусы:**
- Дополнительный шаг в навигации
- Может быть упущен пользователями
- Усложняет меню

#### Опция 2: Контекстное отображение в разделе "Подписка" ✅
**Плюсы:**
- Естественный workflow - все о подписке в одном месте
- Адаптивный контент под текущее состояние
- Минимум кликов для управления

**Минусы:**
- Более сложная логика отображения
- Возможная перегрузка интерфейса

#### Опция 3: Всплывающие уведомления + inline кнопки
**Плюсы:**
- Проактивные уведомления
- Быстрые действия через inline кнопки

**Минусы:**
- Может быть навязчивым
- Ограниченные возможности отображения информации

### ✅ РЕКОМЕНДУЕМЫЙ ПОДХОД: Контекстное отображение

**Реализация:**
- Раздел "💳 Подписка" адаптивно показывает контент:
  - С активным автоплатежом: статус, сумма, дата следующего списания, кнопка отключения
  - Без автоплатежа: предложение настроить с преимуществами
  - При истекшей подписке: планы с опцией автоплатежа

**5 состояний интерфейса:**
1. **Активная подписка + автоплатеж** → показать статус и управление
2. **Активная подписка без автоплатежа** → предложить настроить  
3. **Истекающая подписка (≤7 дней)** → срочное предложение автоплатежа
4. **Истекшая подписка** → планы с акцентом на автоплатеж
5. **Новый пользователь** → планы с объяснением автоплатежа

---

## ⚙️ КОМПОНЕНТ 2: Алгоритм повторных попыток при ошибках

### 🎯 ОПИСАНИЕ
Система обработки неудачных автоматических списаний с адаптивными повторными попытками в зависимости от типа ошибки.

### 📋 ТРЕБОВАНИЯ И ОГРАНИЧЕНИЯ
- **Функциональные**: классификация ошибок, адаптивные интервалы retry, уведомления
- **Технические**: интеграция с Robokassa API, асинхронная обработка  
- **Бизнес**: минимизация churn, соблюдение правил банков

### 🔄 АНАЛИЗ ОПЦИЙ

#### Опция 1: Фиксированные интервалы (24ч - 48ч - 72ч)
**Плюсы:**
- Простота реализации
- Предсказуемое поведение

**Минусы:**
- Не учитывает тип ошибки
- Может быть неэффективным

#### Опция 2: Экспоненциальная задержка
**Плюсы:**
- Снижает нагрузку на систему
- Стандартный подход

**Минусы:**
- Слишком быстро увеличивает интервалы
- Не подходит для недостатка средств

#### Опция 3: Адаптивный подход по типу ошибки ✅
**Плюсы:**
- Оптимизирован под разные ситуации
- Учитывает специфику платежей
- Максимизирует успешность

**Минусы:**
- Сложнее в реализации
- Требует классификации ошибок

### ✅ РЕКОМЕНДУЕМЫЙ ПОДХОД: Адаптивные интервалы

**Классификация ошибок:**

1. **Недостаток средств** (самая частая)
   - Интервалы: 24ч → 72ч → 7 дней (3 попытки)
   - Логика: дать время пополнить счет

2. **Технические ошибки банка/API**
   - Интервалы: 1ч → 6ч → 24ч (3 попытки)  
   - Логика: быстрее повторить при технических сбоях

3. **Проблемы с картой** (заблокирована, истекла)
   - Интервалы: 24ч (1 попытка)
   - Логика: требует вмешательства пользователя

4. **Отмена пользователем**
   - Интервалы: не повторять
   - Логика: отключить автоплатеж

**Алгоритм:**
```python
def get_retry_schedule(error_type: str, attempt: int) -> Optional[timedelta]:
    schedules = {
        'insufficient_funds': [
            timedelta(days=1),    # 24ч
            timedelta(days=3),    # 72ч  
            timedelta(days=7)     # 7 дней
        ],
        'technical_error': [
            timedelta(hours=1),   # 1ч
            timedelta(hours=6),   # 6ч
            timedelta(days=1)     # 24ч
        ],
        'card_issue': [
            timedelta(days=1)     # 24ч, только 1 попытка
        ]
    }
    
    if attempt <= len(schedules.get(error_type, [])):
        return schedules[error_type][attempt - 1]
    return None  # Превышен лимит попыток
```

---

## 📱 КОМПОНЕНТ 3: Система уведомлений пользователей

### 🎯 ОПИСАНИЕ
Комплексная система уведомлений для информирования пользователей о статусе автоплатежей, успешных/неудачных списаниях и необходимых действиях.

### 📋 ТРЕБОВАНИЯ И ОГРАНИЧЕНИЯ
- **Функциональные**: уведомления по статусам, настройки частоты, отложенная отправка
- **UX**: не быть навязчивыми, четкие call-to-action
- **Технические**: интеграция с Telegram Bot API, планирование отправки

### 🔄 АНАЛИЗ ОПЦИЙ

#### Опция 1: Все уведомления сразу при событии
**Плюсы:**
- Мгновенная информативность
- Простота реализации

**Минусы:**
- Может быть навязчивым
- Спам при множественных ошибках

#### Опция 2: Батчинг уведомлений (1 раз в день)
**Плюсы:**
- Не перегружает пользователя
- Консолидированная информация

**Минусы:**
- Задержка в получении важной информации
- Менее реактивный UX

#### Опция 3: Адаптивные уведомления с приоритетами ✅
**Плюсы:**
- Балансирует информативность и UX
- Настраиваемые пользователем
- Учитывает важность событий

**Минусы:**
- Сложнее в реализации
- Требует пользовательские настройки

### ✅ РЕКОМЕНДУЕМЫЙ ПОДХОД: Адаптивные уведомления

**Типы уведомлений:**

1. **Критические** (отправляем сразу):
   - Успешное продление подписки
   - Отключение автоплатежа пользователем
   - Финальная неудача автоплатежа

2. **Важные** (отправляем с задержкой 2ч):
   - Первая неудача автоплатежа
   - Настройка автоплатежа

3. **Информационные** (батчинг раз в день):
   - Напоминание о предстоящем списании (за 3 дня)
   - Статистика автоплатежей (раз в месяц)

**Шаблоны сообщений:**

```
✅ УСПЕШНОЕ ПРОДЛЕНИЕ  
"Подписка активна. Ты на волне! 🌊

💰 Списано: 299₽
📅 Следующее списание: 15.02.2024
⚡ Автоплатеж работает как часы!"

[💳 Управление подпиской] [🛠 Поддержка]

❌ ОШИБКА АВТОПЛАТЕЖА (попытка 1)
"Оп, карта не сработала 😕 Попробуем ещё!

❌ Причина: недостаточно средств на карте
🔄 Повторная попытка: через 24 часа
💡 Пока что всё под контролем"

[💳 Пополнить карту] [🛠 Поддержка]

⚠️ ВТОРАЯ НЕУДАЧНАЯ ПОПЫТКА  
"Хм, опять что-то пошло не так 🤔

❌ Причина: недостаточно средств  
🔄 Последняя попытка: через 72 часа
⏰ Подписка истекает через 5 дней

Самое время что-то предпринять!"

[💳 Обновить способ оплаты] [❌ Отключить автоплатеж] [🛠 Поддержка]

🚨 ФИНАЛЬНАЯ НЕУДАЧА АВТОПЛАТЕЖА
"Автоплатеж не прошёл 😔 Но мы тебя не бросаем!

💔 Все попытки исчерпаны
📅 Подписка истекает завтра
🎯 Продли вручную, чтобы не потерять доступ"

[💳 Продлить подписку] [❌ Отключить автоплатеж] [🛠 Поддержка]

⚠️ ПОДПИСКА ИСТЕКАЕТ
"Автоплатеж отключен. Время не ждёт! ⏱️

📅 Действует до: 12.02.2024  
💡 Продли, чтобы не остаться без VPN"

[💳 Продлить подписку] [⚡ Настроить автоплатеж] [🛠 Поддержка]
```

---

## 🔧 ТЕХНИЧЕСКАЯ ИНТЕГРАЦИЯ С ROBOKASSA

### 💳 Механизм Recurring платежей

**Первый платеж (Setup):**
```python
# 1. Создаем платеж с флагом recurring
payment_params = {
    'MerchantLogin': shop_id,
    'OutSum': amount,
    'InvId': order_id,
    'Description': description,
    'Recurring': 'true',  # Ключевой параметр!
    'IsTest': test_mode
}

# 2. После успешной оплаты Robokassa возвращает recurring_id
# 3. Сохраняем recurring_id в нашей БД для последующих списаний
```

**Автоматические списания:**
```python
# Используем Robokassa Recurring API
recurring_url = "https://auth.robokassa.ru/Merchant/Recurring"

params = {
    'MerchantLogin': shop_id,
    'OutSum': amount,
    'PreviousInvoiceID': recurring_id,  # ID от первого платежа
    'Description': 'Автопродление подписки'
}

# Отправляем POST запрос для списания
# При успехе - продлеваем подписку  
# При ошибке - запускаем retry алгоритм
```

**Отмена автоплатежей:**
```python
# Отмена recurring подписки
cancel_url = "https://auth.robokassa.ru/Merchant/CancelRecurring"

params = {
    'MerchantLogin': shop_id,
    'ID': recurring_id
}

# Отправляем запрос на отмену
# Обновляем статус в БД
```

### 🔄 Полный Workflow автоплатежей

1. **Пользователь выбирает** "⚡ План + Автоплатеж" в боте
2. **Система создает** платеж с `recurring: true`
3. **Пользователь оплачивает** через Robokassa (вводит карту)
4. **Robokassa сохраняет** токен карты, возвращает `recurring_id`
5. **Система настраивает** автоподписку в БД
6. **Cron запускается** каждый час, проверяет due платежи
7. **Система отправляет** recurring запрос в Robokassa
8. **При успехе** - продлевает подписку, при ошибке - retry
9. **Пользователь может** отключить автоплатеж в любой момент

---

## 🎨🎨🎨 ВЫХОД ИЗ ТВОРЧЕСКОЙ ФАЗЫ

**Результаты проектирования:**

✅ **UX интерфейс**: Контекстное отображение в разделе "Подписка" с 5 адаптивными состояниями

✅ **Алгоритм retry**: Адаптивные интервалы по типу ошибки (недостаток средств, технические, проблемы карты)

✅ **Система уведомлений**: Приоритизированные уведомления (критические, важные, информационные)

✅ **Техническая интеграция**: Полная схема Robokassa Recurring API с setup, списаниями и отменой

**Готовность к реализации**: Все проектные решения детализированы с техническими спецификациями и готовы для implement фазы. 

## 🔧 ТЕХНИЧЕСКИЕ УЛУЧШЕНИЯ

### 🎯 Retry-алгоритм с аналитикой

**Сохранение попыток для дебага:**
```python
class PaymentRetryAttempt(Base):
    auto_payment_id = Column(Integer, ForeignKey('auto_payments.id'))
    attempt_number = Column(Integer, nullable=False)
    error_type = Column(String, nullable=False)  # 'insufficient_funds', 'technical_error', 'card_issue'
    error_message = Column(Text)  # Полный текст ошибки
    robokassa_response = Column(Text)  # Raw ответ для дебага
    scheduled_at = Column(DateTime, nullable=False)
    attempted_at = Column(DateTime)
    result = Column(String)  # 'success', 'failed', 'pending'
    user_notified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=func.now())
```

**Логика уведомлений:**
- 1-я неудача: базовое уведомление "попробуем ещё"  
- 2-я неудача: CTA "Пополните карту" / "Обновите карту"
- 3-я неудача: финальное уведомление с отключением

### 💳 Robokassa API улучшения

**Проверка recurring_id перед списанием:**
```python
async def validate_recurring_id(recurring_id: str) -> Dict:
    status_result = await get_recurring_status(recurring_id)
    
    return {
        'valid': status_result.get('status') == 'active',
        'status': status_result.get('status'),
        'message': 'Recurring ID активен' if valid else 'Неактивен'
    }
```

**Корректный формат подписи для Recurring API:**
```python
def _generate_recurring_signature(params: Dict, password: str) -> str:
    # Для создания: MerchantLogin:OutSum:PreviousInvoiceID:Password
    # Для отмены: MerchantLogin:ID:Password
    
    if 'PreviousInvoiceID' in params:
        signature_string = f"{params['MerchantLogin']}:{params['OutSum']}:{params['PreviousInvoiceID']}:{password}"
    elif 'ID' in params:
        signature_string = f"{params['MerchantLogin']}:{params['ID']}:{password}"
    
    return hashlib.md5(signature_string.encode('utf-8')).hexdigest()
```

**Хранение recurring_id в БД:**
```python
class UserSubscription(Base):
    # ... существующие поля
    robokassa_recurring_id = Column(String(255), unique=True)
    next_billing_date = Column(DateTime)  # Ключевое поле для cron
    auto_payment_enabled = Column(Boolean, default=False)
    auto_payment_status = Column(String)  # 'active', 'paused', 'cancelled'
```

**Cron планировщик (каждый час):**
```python
async def process_due_autopayments():
    current_time = datetime.now()
    
    # Находим подписки по next_billing_date
    due_subscriptions = await db.execute(
        select(UserSubscription)
        .where(
            and_(
                UserSubscription.auto_payment_enabled == True,
                UserSubscription.next_billing_date <= current_time
            )
        )
    )
    
    for subscription in due_subscriptions.scalars():
        # Проверяем recurring_id перед списанием
        validation = await validate_recurring_id(subscription.robokassa_recurring_id)
        
        if validation['valid']:
            await process_autopayment(subscription)
        else:
            await handle_invalid_recurring_id(subscription, validation)
``` 